## rxjs5 随想录

### 起源
- rxjs5是“革命派”，不是“革新派”。当我们还习惯于使用基于“pull”的离散孤立数据逻辑单元组织解构复杂的业务和交互逻辑时,rxjs5已经悄无声息的把基于"push"的连续(stream)可轻易相互转化并任意组合的流式响应式数据层解决方案带给了前端同学们。从此，当我们面对复杂的糅合了同步和异步，并且有协作或者竞争等等逻辑关系时，可以微微一笑，心中默念 “rxjs 在手，天下我有”。

### 形式化
- 我们都喜欢形式化，好像只有可以形式化的东西，才是科学的，可以被信任的东西。
- react给我们做了一个很好的榜样，view = f(state), 即针对不同的输入state，返回不同的 view。因此，当我们用 react 解决 view 层的问题时，时时刻刻都在想的是如何抽象 state。
- 同样的，当我们开始用rxjs的视角在数据层建模时，我们需要遵循的真理是:
```js
   result_stream = origin_stream.tranform1()
                                .tranform2()
                                ...;
```
- 稍微简单的介绍下，由rxjs构造的世界里基本单元是 stream(流)，流是一个二维的概念，除了值之外自动的帮你添加了时间的维度，即 stream_value = stream(stream_time)。tranform1 和 tranform2 被称为操作符，将一个流转化为另外一个流，即 new_stream = operator(old_stream)。所以，上面那一段不太好理解的代码就可以转化为文字：当我们使用rxjs给数据层建模时，实际上就是经历了：从初始流不断转化或者组合变成目标流的样子。
- 是不是有点难以理解，没关系下文我们会通过一个实际的例子将这种方法论进行详细的说明。

### 实际例子背景介绍
